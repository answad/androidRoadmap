# 선언형 UI

### 선언형 UI란

- 선언형 UI는 기존의 방식인 명령형 UI의문제를 해결하기위해 생겼다
- 동작을 명시적으로 선언하여 표현하는 방식
    - 이 방식은 어떤 상태에 대한 UI를 설명하고 해당 상태가 변경될 때 자동으로 UI를 업데이트한다
        - 사용자가 UI의 외형을 직접 그리는 대신에 UI가 어떻게 보이고 동작해야 하는지를 선언적으로 설명한다

# Compose란

- Jetpack Compose는 UI 개발을 간소화하기 위해 설계된 최신 툴킷이다
    - 반응형 프로그래밍 모델을 Kotlin 프로그래밍 언어의 간결함 및 사용 편의성과 결합했다
        - 완전히 선언적인 접근 방식으로, 데이터를 UI 계층 구조로 변환하는 일련의 함수를 호출하여 UI를 묘사한다
            - 기본 데이터가 변경되면 프레임워크가 이러한 함수를 자동으로 다시 실행하여 UI 계층 구조를 업데이트한다

# compose특징

- 구성 가능한 함수는 순서와 관계없이 실행할 수 있다
- 구성 가능한 함수는 동시에 실행할 수 있다
- 재구성은 최대한 많은 수의 구성 가능한 함수 및 람다를 건너뛴다
- 재구성은 낙관적이며 취소될 수 있다
- 구성 가능한 함수는 애니메이션의 모든 프레임에서와 같은 빈도로 매우 자주 실행될 수 있다

### 구성 가능한 함수는 순서와 관계없이 실행할 수 있음

```kt
@Composable
fun ButtonRow() {
    MyFancyNavigation {
        StartScreen()
        MiddleScreen()
        EndScreen()
    }
}
```

- 이런식으로 StartScreen(), MiddleScreen(), EndScreen()들이 순차적으로 실행되지 않는다

### 구성 가능한 함수는 동시에 실행할 수 있음

```kt
@Composable
@Deprecated("Example with bug")
fun ListWithBug(myList: List<String>) {
    var items = 0

    Row(horizontalArrangement = Arrangement.SpaceBetween) {
        Column {
            for (item in myList) {
                Text("Item: $item")
                items++ // Avoid! Side-effect of the column recomposing.// 
            }
        }
        Text("Count: $items")// text가 리컴포즈 되야하는데 리컴포즈 최소 스코프에 Column도 포함되있어서 같이 리컴포즈된다 
    }
}
```

- Compose는 구성 가능한 함수를 동시에 실행하여(다중코어) 재구성을 최적화할 수 있다
- 화면에 없는 구성 가능한 함수를 낮은 우선순위로 실행할 수 있다
- 구성 가능한 함수가 ViewModel에서 함수를 호출하면 Compose는 동시에 여러 스레드에서 이 함수를 호출할 수 있다
- 애플리케이션이 올바르게 작동하도록 하려면 모든 구성 가능한 함수에 부작용(side-effect)이 없어야 한다
    - 대신 UI 스레드에서 항상 실행되는 onClick과 같은 콜백에서 부작용을 트리거한다

### 재구성은 가능한 한 많이 건너뜀

- UI에 변경이 생긴 경우 업데이트 해야하는 부분만 리컴포즈 하기 위해서 노력한다
    - UI 트리에서 위 또는 아래에 있는 컴포저블을 실행하지않고 그 부분만 실행할수 있다

### 재구성은 낙관적임

- Compose가 컴포저블의 매개변수가 변경되었을 수 있다고 생각할 때마다 재구성이 시작됨
- 재구성이 완료되기 전에 매개변수가 변경되면 Compose는 재구성을 취소하고 새 매개변수를 사용하여 재구성을 시작한다
- 재구성이 취소되면 Compose는 재구성에서 UI 트리를 삭제한다

### 구성 가능한 함수는 매우 자주 실행될 수 있음

- 경우에 따라 구성 가능한 함수는 UI 애니메이션의 모든 프레임에서 실행될 수 있다
    - 함수가 기기 저장소에서 읽기와 같이 비용이 많이 드는 작업을 실행하면 이 함수로 인해 UI 버벅거림이 발생할 수 있다
- 예를 들어 위젯이 기기 설정을 읽으려고 하면 잠재적으로 이 설정을 초당 수백 번 읽을 수 있으며 이는 앱 성능에 치명적인 영향을 줄 수 있다
- 구성 가능한 함수에 데이터가 필요하다면 데이터의 매개변수를 정의해야 한다
    - 그런 다음, 비용이 많이 드는 작업을 구성 외부로 이동하고 mutableStateOf 또는 LiveData를 사용하여 Compose에 데이터를 전달한다